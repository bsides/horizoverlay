<!doctype html>
<html lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-50702825-3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'UA-50702825-3');
  </script>
  <script>
    var QueryString = (function () {
      // This function is anonymous, is executed immediately and
      // the return value is assigned to QueryString!
      var query_string = {}
      var query = window.location.search.substring(1)
      var vars = query.split('&')
      for (var i = 0; i < vars.length; i++) {
        var pair = vars[i].split('=')
        // If first entry with this name
        if (typeof query_string[pair[0]] === 'undefined') {
          query_string[pair[0]] = decodeURIComponent(pair[1])
          // If second entry with this name
        } else if (typeof query_string[pair[0]] === 'string') {
          var arr = [query_string[pair[0]], decodeURIComponent(pair[1])]
          query_string[pair[0]] = arr
          // If third or later entry with this name
        } else {
          query_string[pair[0]].push(decodeURIComponent(pair[1]))
        }
      }
      return query_string
    })()

    // webs
    var host_port = QueryString['HOST_PORT']
    var need_to_get_host_port = false
    var need_to_set_wsuri = typeof wsUri === 'undefined'

    if (need_to_set_wsuri) {
      window.wsUri = 'ws://@HOST_PORT@/MiniParse'
      need_to_get_host_port = typeof host_port === 'undefined'
    } else {
      need_to_get_host_port =
        typeof host_port === 'undefined' ? wsUri.indexOf('HOST_PORT') === -1 : true
    }

    if (need_to_get_host_port) {
      // ws://localhost:10501/
      if (window.location.host != '')
        host_port = 'ws://' + window.location.host + '/'
      else host_port = 'ws://localhost:10501/'
    }

    // wsUri check
    if (wsUri.indexOf('@HOST_PORT') !== -1) {
      while (host_port.endsWith('/')) {
        host_port = host_port.substring(0, host_port.length - 1)
      }

      if (wsUri.indexOf('//') == 0) {
        wsUri = wsUri.substring(2)
      }

      if (wsUri.indexOf('ws://') == 0 || wsUri.indexOf('wss://') == 0) {
        if (host_port.indexOf('ws://') == 0 || host_port.indexOf('wss://') == 0) {
          wsUri = wsUri.replace(/ws:\/\/@HOST_PORT@/im, host_port)
          wsUri = wsUri.replace(/wss:\/\/@HOST_PORT@/im, host_port)
        } else {
          wsUri = wsUri.replace(/@HOST_PORT@/im, host_port)
        }
      } else {
        if (host_port.indexOf('ws://') == 0 || host_port.indexOf('wss://') == 0) {
          wsUri = wsUri.replace(/@HOST_PORT@/im, host_port)
        } else {
          wsUri = 'ws://' + wsUri.replace(/@HOST_PORT@/im, host_port)
        }
      }
    }

    class ActWebsocketInterface {
      constructor(uri, path = 'MiniParse') {
        // url check
        var querySet = this.getQuerySet()
        if (typeof querySet['HOST_PORT'] != 'undefined') {
          uri = querySet['HOST_PORT'] + path
        }
        this.uri = uri
        this.id = null
        this.activate = false

        var This = this
        document.addEventListener('onBroadcastMessage', function (evt) {
          This.onBroadcastMessage(evt)
        })
        document.addEventListener('onRecvMessage', function (evt) {
          This.onRecvMessage(evt)
        })
        window.addEventListener('message', function (e) {
          if (e.data.type === 'onBroadcastMessage') {
            This.onBroadcastMessage(e.data)
          }
          if (e.data.type === 'onRecvMessage') {
            This.onRecvMessage(e.data)
          }
        })
      }
      connect() {
        if (typeof this.websocket != 'undefined' && this.websocket != null)
          this.close()
        this.activate = true
        var This = this
        this.websocket = new WebSocket(this.uri)
        this.websocket.onopen = function (evt) {
          This.onopen(evt)
        }
        this.websocket.onmessage = function (evt) {
          This.onmessage(evt)
        }
        this.websocket.onclose = function (evt) {
          This.onclose(evt)
        }
        this.websocket.onerror = function (evt) {
          This.onerror(evt)
        }
      }
      close() {
        this.activate = false
        if (this.websocket != null && typeof this.websocket != 'undefined') {
          this.websocket.close()
        }
      }
      onopen(evt) {
        // get id from useragent
        if (this.id != null && typeof this.id != 'undefined') {
          this.set_id(this.id)
        } else {
          if (typeof overlayWindowId != 'undefined') {
            this.set_id(overlayWindowId)
          } else {
            var r = new RegExp(
              '[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}'
            )
            var id = r.exec(navigator.userAgent)
            if (id != null && id.length == 1) {
              this.set_id(id[0])
            }
          }
        }
      }
      onclose(evt) {
        this.websocket = null
        if (this.activate) {
          var This = this
          setTimeout(function () {
            This.connect()
          }, 5000)
        }
      }
      onmessage(evt) {
        if (evt.data == '.') {
          // ping pong
          this.websocket.send('.')
        } else {
          try {
            var obj = JSON.parse(evt.data)
            var type = obj['type']
            if (type == 'broadcast') {
              var from = obj['from']
              var type = obj['msgtype']
              var msg = obj['msg']
              document.dispatchEvent(
                new CustomEvent('onBroadcastMessage', { detail: obj })
              )
            }
            if (type == 'send') {
              var from = obj['from']
              var type = obj['msgtype']
              var msg = obj['msg']
              document.dispatchEvent(
                new CustomEvent('onRecvMessage', { detail: obj })
              )
            }
            if (type == 'set_id') {
              //document.dispatchEvent(new CustomEvent('onIdChanged', { detail: obj }));
            }
          } catch (e) { }
        }
      }
      onerror(evt) {
        this.websocket.close()
        console.log(evt)
      }
      getQuerySet() {
        var querySet = {}
        // get query
        var query = window.location.search.substring(1)
        var vars = query.split('&')
        for (var i = 0; i < vars.length; i++) {
          try {
            var pair = vars[i].split('=')
            querieSet[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1])
          } catch (e) { }
        }
        return querySet
      }

      broadcast(type, msg) {
        if (typeof overlayWindowId != 'undefined' && this.id != overlayWindowId) {
          this.set_id(overlayWindowId)
        }
        var obj = {}
        obj['type'] = 'broadcast'
        obj['msgtype'] = type
        obj['msg'] = msg
        this.websocket.send(JSON.stringify(obj))
      }

      send(to, type, msg) {
        if (typeof overlayWindowId != 'undefined' && this.id != overlayWindowId) {
          this.set_id(overlayWindowId)
        }
        var obj = {}
        obj['type'] = 'send'
        obj['to'] = to
        obj['msgtype'] = type
        obj['msg'] = msg
        this.websocket.send(JSON.stringify(obj))
      }

      overlayAPI(type, msg) {
        var obj = {}
        if (typeof overlayWindowId != 'undefined' && this.id != overlayWindowId) {
          this.set_id(overlayWindowId)
        }
        obj['type'] = 'overlayAPI'
        obj['to'] = overlayWindowId
        obj['msgtype'] = type
        obj['msg'] = msg
        this.websocket.send(JSON.stringify(obj))
      }

      set_id(id) {
        var obj = {}
        obj['type'] = 'set_id'
        obj['id'] = id
        this.id = overlayWindowId
        this.websocket.send(JSON.stringify(obj))
      }

      onRecvMessage(e) { }

      onBroadcastMessage(e) { }
    }

    /*
    class ActWebSocketImpl extends ActWebsocketInterface
    {
      constructor(uri, path = "MiniParse") {
        super(uri, path);
      }
      //send(to, type, msg)
      //broadcast(type, msg)
      onRecvMessage(e)
      {
      }

      onBroadcastMessage(e)
      {
        if(e.detail.msgtype == "CombatData")
        {
          document.dispatchEvent(new CustomEvent('onOverlayDataUpdate', { detail: e.detail.msg }));
        }
      }
    };
    */

    /* ACTWebSocket  Begin */

    class WebSocketImpl extends ActWebsocketInterface {
      constructor(uri, path = 'MiniParse') {
        super(uri, path)
      }
      //send(to, type, msg)
      //broadcast(type, msg)
      onRecvMessage(e) { }

      onBroadcastMessage(e) {
        if (e.detail.msgtype == 'CombatData') {
          document.dispatchEvent(
            new CustomEvent('onOverlayDataUpdate', { detail: e.detail.msg })
          )
        }
      }
    }

    var webs = null
    function ready(fn) {
      if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        fn();
      } else {
        document.addEventListener('DOMContentLoaded', fn);
      }
    }
    ready(function () {
      webs = new WebSocketImpl(wsUri)
      webs.connect()
    })
    if (document.addEventListener) {
      window.onbeforeunload = function () {
        webs.close()
      }
      window.addEventListener(
        'unload',
        function () {
          webs.close()
        },
        false
      )
    }

/* ACTWebSocket  End */
  </script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#000000">
  <!--
      manifest.json provides metadata used when your web app is added to the
      homescreen on Android. See https://developers.google.com/web/fundamentals/engage-and-retain/web-app-manifest/
    -->
  <link rel="manifest" href="%PUBLIC_URL%/manifest.json">
  <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico">
  <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
  <title>Horizoverlay</title>
</head>

<body>
  <noscript>
    You need to enable JavaScript to run this app.
  </noscript>
  <div id="root"></div>
  <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
</body>

</html>
